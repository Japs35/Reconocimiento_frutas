# -*- coding: utf-8 -*-
"""RNN_frutas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YunF0uBkKq_W6Mcq4HjuZmIwhEMxd6Tu

Red neuronal convolucional
```
# Tiene formato de código
```
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras import Sequential,layers
import os                                         #manejo de archivos
import cv2                                        #procesamiento de imagenes
import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing import image_dataset_from_directory     #generamos base de datos a partir de las imagenes
from tensorflow.keras.preprocessing.image import ImageDataGenerator

from google.colab import drive
drive.mount('/content/drive')

path_train = "/content/drive/MyDrive/Redes Neuronales/Proyecto 2/train"

#Indicamos las carpetas que existen dentro de la carpeta train:

print(os.listdir(path_train))

#Ingresamos a la carpeta train y con el for ingresamos la carpeta podridos y frescos

nt=0      #contamos el total de imagenes

for i in os.listdir(path_train):
  num=len(os.listdir(path_train+"/"+i))
  print("Número de imagenes con la etiqueta \"{}\" es:  {}".format(i,num))
  nt=nt+num
print("Total de imagenes: {}",format(nt))

#Parámetros básicos

img_height = 200
img_width = 200
batch_size = 16         #Formamos 7 lotes, 6 de 16 y 1 de 7

#Cargar los datos de entrenamiento

train_ds = image_dataset_from_directory(            #Me permite extraer los patrones de la carpeta raiz
    path_train,
    #seed=123,
    image_size=(img_height,img_width),              #la imagen original se convierte a una imagen de 200 x 200
    batch_size=batch_size,
    label_mode="categorical")                            #ya no puedo hacer el modelo binario sino una salida categorica

#Preprocesamiento: Normalización de las imagenes

normalization_layer = layers.Rescaling(1./255)
train_ds = train_ds.map(lambda x, y: (normalization_layer(x), y))     #a cada imagen de entrenamiento, los pixeles se dividen entre 255

#Modelo CNN categorica, voy a tener 3 salidas

modelo = Sequential([  layers.Input(shape=(img_height,img_width,3)),
                      layers.Conv2D(16,(3,3),activation="relu"),
                      layers.MaxPooling2D(2,2),
                      layers.Conv2D(32,(3,3),activation="relu"),
                      layers.MaxPooling2D(2,2),
                      layers.Conv2D(64,(3,3),activation="relu"),
                      layers.MaxPooling2D(2,2),
                      layers.Conv2D(64,(3,3),activation="relu"),
                      layers.MaxPooling2D(2,2),
                      layers.Conv2D(64,(3,3),activation="relu"),
                      layers.MaxPooling2D(2,2),
                      layers.Flatten(),
                      layers.Dense(512,activation="relu"),
                      layers.Dense(3,activation="softmax")])

modelo.summary()

from tensorflow.keras.optimizers import Adam

modelo.compile(optimizer=Adam(learning_rate=0.002),
               loss="categorical_crossentropy",
               metrics=["accuracy"])

num_lotes=len(train_ds)
print(num_lotes)

history=modelo.fit(train_ds,epochs=26 )

train_acc=history.history["accuracy"]
epochs=range(1,len(train_acc)+1)
plt.plot(epochs,train_acc,"b",label="Training accuracy")
plt.title("Epocas vs ACC")
plt.legend()
plt.figure()
plt.show()

#test

from tensorflow.keras.preprocessing import image

path_img_test="/content/drive/MyDrive/Redes Neuronales/Proyecto 2/train/platanos/Screen Shot 2018-06-12 at 9.39.17 PM.png"
img=  image.load_img(path_img_test,target_size=(img_height,img_width))

#Convierto la imagen en matriz
x=image.img_to_array(img)
x=np.expand_dims(x,axis=0)
imagen=np.vstack([x])

#Abrimos la imagen
from google.colab.patches import cv2_imshow
img=cv2.imread(path_img_test)
res=cv2.resize(img,(100,100))
cv2_imshow(res)


y_pred=modelo.predict(imagen)
print(y_pred)

#####################################

print("{}% de probabilidad que sea manzana".format(y_pred[0][0]*100))
print("{}% de probabilidad que sea naranja".format(y_pred[0][1]*100))
print("{}% de probabilidad que sea banana".format(y_pred[0][2]*100))

#Guardar una red neuronal
path_json="/content/drive/MyDrive/Redes Neuronales/Modelos entrenados/Frutas/frutas.json"
path_h5="/content/drive/MyDrive/Redes Neuronales/Modelos entrenados/Frutas/frutas.weights.h5"

with open(path_json,"w") as json_file:
  modelo_json=modelo.to_json()
  json_file.write(modelo.to_json())
json_file.close()

modelo.save_weights(path_h5)
print("Modelo guardado!!")









